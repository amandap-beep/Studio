<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>AR.js + p5.js Multi-Marker Tracking</title>
  
  <!-- AR.js -->
  <script src="https://cdn.jsdelivr.net/gh/aframevr/aframe@1c2407b26c61958baa93967b5412487cd94b290b/dist/aframe-master.min.js"></script>
  <script src="https://raw.githack.com/AR-js-org/AR.js/master/aframe/build/aframe-ar-nft.js"></script>
  
  <!-- p5.js -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.7.0/p5.min.js"></script>
  
  <style>
    body {
      margin: 0;
      overflow: hidden;
    }
    
    #arCanvas {
      position: absolute;
      top: 0;
      left: 0;
      z-index: 1;
    }
    
    #info {
      position: absolute;
      top: 10px;
      left: 10px;
      color: white;
      background: rgba(0, 0, 0, 0.7);
      padding: 10px;
      font-family: monospace;
      z-index: 100;
      border-radius: 5px;
    }
  </style>
</head>
<body>
  <div id="info">
    <div>Marker Status: <span id="status">Not Detected</span></div>
    <div>Active Marker: <span id="activeMarker">None</span></div>
  </div>

  <!-- A-Frame Scene for AR.js -->
  <a-scene
    embedded
    arjs="sourceType: webcam; debugUIEnabled: false; detectionMode: mono_and_matrix; matrixCodeType: 3x3;"
    vr-mode-ui="enabled: false">
    
    <!-- Camera -->
    <a-entity camera></a-entity>
    
    <!-- Marker 1: Hiro pattern (default AR.js marker) -->
    <a-marker id="marker1" type="pattern" preset="hiro">
      <a-entity id="content1"></a-entity>
    </a-marker>
    
    <!-- Marker 2: Kanji pattern (default AR.js marker) -->
    <a-marker id="marker2" type="pattern" preset="kanji">
      <a-entity id="content2"></a-entity>
    </a-marker>
    
    <!-- Marker 3: Custom pattern (you'll add your own .patt file) -->
    <!-- Uncomment and replace with your custom marker -->
    <!--
    <a-marker id="marker3" type="pattern" url="path/to/your/marker.patt">
      <a-entity id="content3"></a-entity>
    </a-marker>
    -->
  </a-scene>

  <!-- p5.js Canvas -->
  <div id="arCanvas"></div>

  <script>
    // Global variables
    let currentMarker = null;
    let markerDetected = false;
    let animationFrame = 0;
    
    // Marker-specific animation states
    let markers = {
      marker1: {
        name: 'Hiro',
        detected: false,
        animFrame: 0,
        color: null,
        rotation: 0
      },
      marker2: {
        name: 'Kanji',
        detected: false,
        animFrame: 0,
        color: null,
        rotation: 0
      }
    };

    function setup() {
      let canvas = createCanvas(windowWidth, windowHeight, WEBGL);
      canvas.parent('arCanvas');
      
      // Initialize colors for each marker
      markers.marker1.color = color(255, 100, 100);
      markers.marker2.color = color(100, 100, 255);
      
      // Set up AR.js marker event listeners
      setupMarkerListeners();
      
      frameRate(30);
    }

    function draw() {
      clear();
      
      // Only draw if a marker is detected
      if (markerDetected && currentMarker) {
        let markerData = markers[currentMarker];
        
        // Increment animation frame
        markerData.animFrame++;
        
        // Draw based on which marker is active
        push();
        
        // Different animation for each marker
        if (currentMarker === 'marker1') {
          drawMarker1Animation(markerData);
        } else if (currentMarker === 'marker2') {
          drawMarker2Animation(markerData);
        }
        
        pop();
      }
      
      // Update UI
      updateUI();
    }

    function drawMarker1Animation(markerData) {
      // Pulsing rotating cube
      let scale = 50 + sin(markerData.animFrame * 0.05) * 20;
      markerData.rotation += 0.02;
      
      push();
      rotateX(markerData.rotation);
      rotateY(markerData.rotation * 0.7);
      fill(markerData.color);
      stroke(255);
      strokeWeight(2);
      box(scale);
      pop();
      
      // Orbiting spheres
      for (let i = 0; i < 3; i++) {
        let angle = markerData.animFrame * 0.02 + (TWO_PI / 3) * i;
        let x = cos(angle) * 80;
        let z = sin(angle) * 80;
        
        push();
        translate(x, 0, z);
        fill(255, 200, 200);
        noStroke();
        sphere(15);
        pop();
      }
    }

    function drawMarker2Animation(markerData) {
      // Spinning pyramid with color shift
      markerData.rotation += 0.03;
      
      let colorShift = map(sin(markerData.animFrame * 0.03), -1, 1, 0, 255);
      
      push();
      rotateY(markerData.rotation);
      rotateX(PI);
      fill(colorShift, 100, 255 - colorShift);
      stroke(255);
      strokeWeight(2);
      
      // Draw pyramid (cone)
      translate(0, -30, 0);
      cone(50, 80);
      pop();
      
      // Floating text/particles
      for (let i = 0; i < 5; i++) {
        let yOffset = (markerData.animFrame * 2 + i * 30) % 150 - 75;
        let angle = i * TWO_PI / 5;
        let x = cos(angle) * 60;
        let z = sin(angle) * 60;
        
        push();
        translate(x, yOffset, z);
        fill(255, 255, 100, 200);
        noStroke();
        sphere(8);
        pop();
      }
    }

    function setupMarkerListeners() {
      // Set up listeners for each marker
      Object.keys(markers).forEach(markerId => {
        let markerEl = document.querySelector(`#${markerId}`);
        
        if (markerEl) {
          // Marker found
          markerEl.addEventListener('markerFound', () => {
            console.log(`${markerId} detected`);
            markerDetected = true;
            currentMarker = markerId;
            markers[markerId].detected = true;
            markers[markerId].animFrame = 0; // Reset animation
          });
          
          // Marker lost
          markerEl.addEventListener('markerLost', () => {
            console.log(`${markerId} lost`);
            markers[markerId].detected = false;
            
            // Check if any other marker is still visible
            let anyDetected = Object.keys(markers).some(id => markers[id].detected);
            if (!anyDetected) {
              markerDetected = false;
              currentMarker = null;
            }
          });
        }
      });
    }

    function updateUI() {
      document.getElementById('status').textContent = markerDetected ? 'Detected' : 'Not Detected';
      document.getElementById('activeMarker').textContent = currentMarker 
        ? markers[currentMarker].name 
        : 'None';
    }

    function windowResized() {
      resizeCanvas(windowWidth, windowHeight);
    }
  </script>
</body>
</html>
